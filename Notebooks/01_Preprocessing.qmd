---
title: "Preprocessing"
author: "Brennan Hickson"
format: html
editor: visual
---

# Install and Load Libraries

```{r Initial Setup and Library Loading, echo = TRUE}
# Load the pacman package (install if necessary)
if (!requireNamespace("pacman", quietly = TRUE)) {
  install.packages("pacman")
}

# Install and load prerequisite libraries
pacman::p_load(haven, here, lubridate, sjlabelled, labelled, tidyverse)

# Create the 'Logs' subdirectory if not already accessible
log_dir <- here("Logs")
if (!dir.exists(log_dir)) {
  dir.create(log_dir)
}

# Create the 'Data/Raw' subdirectory if not already accessible
data_raw_dir <- here("Data", "Raw")
if (!dir.exists(data_raw_dir)) {
  dir.create(data_raw_dir, recursive = TRUE)
}

# Create the 'Data/Processed' subdirectory if not already accessible
data_processed_dir <- here("Data", "Processed")
if (!dir.exists(data_processed_dir)) {
  dir.create(data_processed_dir, recursive = TRUE)
}

# Create the 'Output/Plots' subdirectory if not already accessible
plots_dir <- here("Output", "Plots")
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}

# Define the study period start and end dates
study_entry_period_start_date <- as.Date("2006-10-01")
study_entry_period_end_date <- as.Date("2012-10-01")
```

```{r Define a Function to Import the Data}
# Function to import data from a file
import_data <- function(file_path, file_type = c("sav", "csv")) {
  tryCatch({
    if (file_type == "sav") {
      read_sav(file_path)
    } else if (file_type == "csv") {
      read.csv(file_path)
    } else {
      stop("Unsupported file type. Please specify '.sav' or '.csv'.")
    }
  }, error = function(e) {
    cat("Error importing file:", file_path, "\nError message:", e$message, "\n")
    return(NULL)
  })
}
```

```{r Import Data}
# Specify the file paths to the datasets
tbims_form1_path <- here(data_raw_dir, "TBIMS_2023Q2_SPSS/TBIMSForm1_20230712.sav")
tbims_form2_path <- here(data_raw_dir, "TBIMS_2023Q2_SPSS/TBIMSForm2_20230726.sav")
function_scores_path <- here(data_raw_dir, "function_factorscore20240131.csv")

# Import TBIMS Form 1 and Form 2 data
tbims_form1_data <- import_data(tbims_form1_path, file_type = "sav")
tbims_form2_data <- import_data(tbims_form2_path, file_type = "sav")

# Save original TBIMS Form 1 and Form 2 variable labels before proceeding
tbims_form1_labels <- tbims_form1_data |> var_label()
tbims_form2_labels <- tbims_form2_data |> var_label()

# Import function factor scores
function_factor_scores <- import_data(function_scores_path, file_type = "csv")
```

## Define Data Cleaning Functions

```{r Define Data Cleaning Functions: `handle_date_conversion`}
# Function to handle Date conversions and NA replacement
handle_date_conversion <- function(x, na_codes) {
  # Convert to Date if x is not already a Date
  if (!inherits(x, "Date")) {
    x <- as.Date(x)
  }

  # Replace specified na_codes (in Date format) with NA
  na_codes <- lapply(na_codes, function(code) as.Date(code, format = "%Y-%m-%d"))
  for (code in na_codes) {
    x[x == code] <- NA
  }

  return(x)
}
```

```{r Define Data Cleaning Functions: `replace_na`}
# Function to replace missing values and convert data types
replace_na <- function(x, na_codes, to_class = NULL) {
  if (!is.null(to_class)) {
    if (to_class == "factor") {
      x <- as.character(x) # Convert to character first to handle haven_labelled cases
      x[x %in% na_codes] <- NA
      x <- factor(x, exclude = NA)
    } else if (to_class == "numeric") {
      x <- as.numeric(x)
      x[x %in% na_codes] <- NA
    } else if (to_class == "Date") {
      x <- handle_date_conversion(x, na_codes)
    } else if (to_class == "character") {
      x <- as.character(x)
      x[x %in% na_codes] <- NA
    }
  } else {
    # Default handling if to_class is not specified
    x[x %in% na_codes] <- NA
  }
  return(x)
}
```

```{r Define Data Cleaning Functions: `clean_and_convert`}
# Function to clean and convert data based on mapping rules
clean_and_convert <- function(data, mapping_list) {
  for (var in names(mapping_list)) {
    na_values <- mapping_list[[var]]$na_values
    original_name <- mapping_list[[var]]$original_name
    to_class <- mapping_list[[var]]$to_class

    # Renaming the variable
    data <- data |> 
      rename(!!var := all_of(original_name))

    # Replace specified values with NA based on their intended class
    data <- data |> mutate(!!var := replace_na(!!sym(var), na_values, to_class))

    # Handle haven_labelled data if present
    data <- data |> mutate(!!var := haven::zap_labels(!!sym(var)))
  }
  return(data)
}
```

```{r Define the Data Mappings for Data Cleaning}
# Variable name and NA mappings for baseline data
baseline_name_and_na_mappings <- list(
  id = list(original_name = "Mod1id", to_class = "numeric"),
  sex = list(original_name = "SexF", na_values = 99, to_class = "factor"),
  age_at_injury = list(original_name = "AGE", na_values = 9999, to_class = "numeric"),
  date_of_birth = list(original_name = "Birth", na_values = as.Date("9999-09-09"), to_class = "Date"),
  date_of_injury = list(original_name = "Injury", na_values = as.Date("9999-09-09"), to_class = "Date"),
  date_of_death = list(original_name = "Death", na_values = as.Date(c("8888-08-08", "9999-09-09")), to_class = "Date"),
  cause_of_injury = list(original_name = "Cause", na_values = 999, to_class = "factor"),
  marital_status_at_injury = list(original_name = "Mar", na_values = 99, to_class = "factor"),
  education_level_at_injury = list(original_name = "EduYears", na_values = c(21, 666, 999), to_class = "numeric"),
  employment_at_injury = list(original_name = "EMPLOYMENT", na_values = c(888, 999), to_class = "factor"),
  rehab_payor_primary = list(original_name = "RehabPay1", na_values = c(888, 999), to_class = "factor"),
  problematic_substance_use_at_injury = list(original_name = "PROBLEMUse", na_values = c(77, 99), to_class = "factor"),
  mental_health_tx_lifetime_at_injury = list(original_name = "MntlEver", na_values = c(66, 77, 99), to_class = "factor"),
  mental_health_tx_past_year_at_injury = list(original_name = "MntlPrior", na_values = c(66, 77, 99), to_class = "factor"),
  psych_hosp_hx_lifetime_at_injury = list(original_name = "PsyHosp", na_values = c(66, 77, 99), to_class = "factor"),
  psych_hosp_hx_past_year_at_injury = list(original_name = "PsyHospPrior", na_values = c(66, 77, 99), to_class = "factor"),
  suicide_attempt_hx_lifetime_at_injury = list(original_name = "Suicide", na_values = c(66, 77, 99), to_class = "factor"),
  suicide_attempt_hx_past_year_at_injury = list(original_name = "SuicidePrior", na_values = c(66, 77, 99), to_class = "factor"),
  cause_of_death_1 = list(original_name = "DeathCause1", na_values = c(44444, 88888, 99999, "09/09/9999"), to_class = "character"),
  cause_of_death_2 = list(original_name = "DeathCause2", na_values = c(44444, 88888, 99999, "09/09/9999"), to_class = "character"),
  cause_of_death_e = list(original_name = "DeathECode", na_values = c(44444, 88888, 99999, "09/09/9999"), to_class = "character")
  )

# Variable name and NA mappings for follow-up data
followup_name_and_na_mappings <- list(
  id = list(original_name = "Mod1id", to_class = "numeric"),
  data_collection_period = list(original_name = "FollowUpPeriod", to_class = "numeric"),
  status_at_followup = list(original_name = "IntStatus", to_class = "factor"),
  date_of_followup = list(original_name = "Followup", na_values = as.Date(c("4444-04-04", "5555-05-05", "7777-07-07", "8888-08-08", "9999-09-09")), to_class = "Date"),
  date_of_death = list(original_name = "DeathF", na_values = as.Date(c("4444-04-04", "8888-08-08", "9999-09-09")), to_class = "Date"),
  drs_total_at_followup = list(original_name = "DRSF", na_values = 999, to_class = "numeric"),
  fim_total_at_followup = list(original_name = "FIMTOTF", na_values = 9999, to_class = "numeric"),
  gose_total_at_followup = list(original_name = "GOSEF", na_values = c(66, 99), to_class = "numeric"),
  problematic_substance_use_at_followup = list(original_name = "PROBLEMUseF", na_values = c(77, 99), to_class = "factor"),
  suicide_attempt_hx_past_year_at_followup = list(original_name = "SuicideF", na_values = c(66, 77, 88, 99), to_class = "factor"),
  phq1 = list(original_name = "PHQPleasureF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq2 = list(original_name = "PHQDownF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq3 = list(original_name = "PHQSleepF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq4 = list(original_name = "PHQTiredF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq5 = list(original_name = "PHQEAtF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq6 = list(original_name = "PHQBadF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq7 = list(original_name = "PHQConcentrateF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq8 = list(original_name = "PHQSlowF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  phq9 = list(original_name = "PHQDeadF", na_values = c(66, 81, 82, 99), to_class = "numeric"),
  cause_of_death_1 = list(original_name = "DeathCause1F", na_values = c(44444, 88888, 99999), to_class = "character"),
  cause_of_death_2 = list(original_name = "DeathCause2F", na_values = c(44444, 88888, 99999), to_class = "character"),
  cause_of_death_e = list(original_name = "DeathECodeF", na_values = c(44444, 88888, 99999), to_class = "character")
  )
```

```{r Clean Baseline and Follow-up Data}
# Add data collection period to baseline data
tbims_form1_data <- tbims_form1_data |>
  mutate(data_collection_period = 0)

# Clean and convert the Form 1 (baseline) and Form 2 (follow-up) data
clean_tbims_form1_data <- clean_and_convert(tbims_form1_data, baseline_name_and_na_mappings)
clean_tbims_form2_data <- clean_and_convert(tbims_form2_data, followup_name_and_na_mappings)
```

```{r Merge Baseline and Follow-up Data and Coalesce Shared Variables}
# Merge cleaned data
merged_data <- full_join(clean_tbims_form1_data, clean_tbims_form2_data, by = c("id", "data_collection_period"))

# Append Year 1 functional independence scores and coalesce variables shared between TBIMS Form 1 and Form 2
merged_data <- merged_data |>
  left_join(function_factor_scores, by = "id") |>
  rename(func_score_at_year_1 = func) |>
  mutate(
    date_of_death = coalesce(date_of_death.x, date_of_death.y),
    cause_of_death_1 = coalesce(cause_of_death_1.x, cause_of_death_1.y),
    cause_of_death_2 = coalesce(cause_of_death_2.x, cause_of_death_2.y),
    cause_of_death_e = coalesce(cause_of_death_e.x, cause_of_death_e.y)
 )
```

```{r Create the Variable Corresponding to the Date of Each Participant's Year 1 Follow-Up Interview}
# Create the date_of_year_1_followup and impute it
merged_data <- merged_data |>
  # Create the date_of_year_1_followup variable
  left_join(
    merged_data |>
      filter(data_collection_period == 1) |>
      group_by(id) |>
      summarise(date_of_year_1_followup = if (all(is.na(date_of_followup))) NA else min(date_of_followup, na.rm = TRUE)) |>
      filter(!is.na(date_of_year_1_followup)), # Remove rows where date_of_year_1_followup is NA
    by = "id"
  ) |>
  # Impute the date_of_year_1_followup to all subsequent observations per id
  group_by(id) |>
  fill(date_of_year_1_followup, .direction = "downup") |>
  ungroup()
```

```{r Plot a Histogram of Function Factor Scores at Year 1}
# Define a custom theme for the plot
customization <- theme(
  title = element_text(family = "Proxima Nova", face = "bold", size = 15),
  legend.title = element_text(family = "Proxima Nova", face = "bold", size = 10),
  legend.text = element_text(family = "Proxima Nova", size = 9.5),
  axis.title.x = element_text(family = "Proxima Nova", face = "bold", size = 10, margin = margin(t = 10)),
  axis.title.y = element_text(family = "Proxima Nova", face = "bold", size = 10, margin = margin(r = 10)),
  axis.text = element_text(family = "Proxima Nova", size = 10),
  text = element_text(family = "Proxima Nova"),
  legend.position = "top"
)

# Remove non-finite values from the data (NA, NaN, Inf, -Inf)
clean_data <- function_factor_scores[is.finite(function_factor_scores$func), ]

# Create the plot object
plot <- ggplot(data = function_factor_scores, aes(x = func)) +  
  geom_histogram(
    binwidth = 0.15, 
    position = "identity", 
    alpha = 0.6, 
    na.rm = TRUE, 
    fill = "#9575cd",    # Set the fill color directly here
    color = "#9575cd"    # Set the outline color directly here
  ) +
  labs(x = "Function Factor Score Values", y = "Frequency", title = "Distribution of Year 1 Function Factor Scores") +
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = "white"),  # Set background to white
    panel.background = element_rect(fill = "white", color = "white"), # Set panel background to white
    panel.grid.major = element_blank(),  # Optional: Remove gridlines if desired
    panel.grid.minor = element_blank()   # Optional: Remove minor gridlines if desired
  ) +
  scale_x_continuous(
    breaks = seq(-6, 2, by = 1),   # Set x-axis breaks at 1-unit intervals starting from -6 to 2
    limits = c(-6, 2)              # Set x-axis limits from -6 to 2
  ) +
  customization

# Save the plot with 300 DPI
ggsave(here(plots_dir, "function_factor_scores_plot.png"), plot, dpi = 300, width = 8, height = 6)
```

```{r Create the Variable Corresponding to the Function Factor Score Quintiles}
# Calculate quintile cut points
quintile_breaks <- merged_data |>
  filter(data_collection_period == 1) |>
  pull(func_score_at_year_1) |>
  quantile(probs = seq(0, 1, by = 0.20), na.rm = TRUE)

# Ensure quintile cut points are unique
quintile_breaks <- unique(quintile_breaks)

merged_data <- merged_data |>
  # Create and impute quintiles for func_score_at_year_1_q5
  group_by(id) |>
  mutate(
    func_score_at_year_1_q5 = if_else(data_collection_period == 1 & !is.na(func_score_at_year_1),
                                      cut(func_score_at_year_1, breaks = quintile_breaks, include.lowest = TRUE, labels = FALSE),
                                      NA_integer_)
  ) |>
  fill(func_score_at_year_1_q5, .direction = "downup") |>
  ungroup()
```

```{r Define a Function to Update Value Labels}
# Function to update value labels of factor variables defined in mapping lists
update_labels_with_sjlabelled <- function(data, mapping_lists) {
  # Loop through each mapping list
  for (mapping_list in mapping_lists) {
    # Loop through each variable in the mapping list
    for (var_name in names(mapping_list)) {
      # Process only factor variables
      if (is.factor(data[[var_name]])) {
        # Retrieve original labels with numeric values for the variable
        original_labels <- get_labels(data[[var_name]], values = "n")
        # Get current factor levels of the variable
        current_levels <- levels(data[[var_name]])
        # Create a named vector of labels based on current levels
        valid_labels <- original_labels[names(original_labels) %in% current_levels]
        # Update the variable in the dataframe with the new set of labels
        data[[var_name]] <- set_labels(data[[var_name]], labels = valid_labels)
      }
    }
  }
  return(data)
}
```

```{r Update Desired Value Labels}
# Update value labels of variables in the mapping lists
merged_data <- update_labels_with_sjlabelled(merged_data, list(baseline_name_and_na_mappings, followup_name_and_na_mappings))
```

```{r Process the Factor Variables in the Merged Data}
merged_data <- merged_data |>
# Perform additional calculations, collapse factor levels, and convert data types
  mutate(
    # Calculate age at time of injury (if missing)
    age_at_injury = if_else(is.na(age_at_injury), floor(as.duration(interval(date_of_birth, date_of_injury))/dyears(1)), age_at_injury),
    
    # Specify the value labels associated with follow-up interview status
    status_at_followup = fct_recode(status_at_followup,
                                    Followed = "1",
                                    Lost = "2",
                                    Refused = "3",
                                    Incarcerated = "4",
                                    Withdrew = "5",
                                    Expired = "6",
                                    "No Funding" = "7"),
    
    # Set 'Male' as the reference group for sex
    sex = fct_recode(sex,
                     Female = "1",
                     Male = "2"
                     ) |>
    fct_relevel("Male", "Female"),
    
    # Collapse and reorder the levels of the cause of injury covariate
    cause_of_injury = fct_recode(cause_of_injury,
                                 "Motor Vehicle" = "1",
                                 Motorcycle = "2",
                                 Bicycle = "3",
                                 "All-Terrain Vehicle (ATV) and All-Terrain Cycle (ATC)" = "4",
                                 "Other Vehicular: Unclassified" = "5",
                                 "Gunshot Wound" = "10",
                                 "Assaults With Blunt Instrument" = "11",
                                 "Other Violence" = "12",
                                 "Water Sports" = "13",
                                 "Field/Track Sports" = "14",
                                 "Gymnastic Activities" = "15",
                                 "Winter Sports" = "16",
                                 "Air Sports" = "17",
                                 "Other Sports" = "18",
                                 "Fall" = "19",
                                 "Hit By Falling/Flying Object" = "20",
                                 "Pedestrian" = "21",
                                 "Other Unclassified" = "22"
                                 ) |>
      fct_collapse(
        Vehicular = c("Motor Vehicle", "Motorcycle", "Bicycle", "All-Terrain Vehicle (ATV) and All-Terrain Cycle (ATC)",
                      "Other Vehicular: Unclassified"),
        Falls = "Fall",
        Violence = c("Gunshot Wound", "Assaults With Blunt Instrument", "Other Violence"),
        Other = c("Water Sports", "Field/Track Sports", "Gymnastic Activities", "Winter Sports", "Air Sports",
                  "Other Sports", "Hit By Falling/Flying Object", "Pedestrian", "Other Unclassified")
      ) |>
      # Set 'Vehicular' as the reference group for cause of injury
      fct_relevel("Vehicular", "Falls", "Violence", "Other"),
    
    # Collapse and reorder the levels of the marital status at injury covariate
    marital_status_at_injury = fct_recode(marital_status_at_injury,
                                          "Single (Never Married)" = "1",
                                          Married = "2",
                                          Divorced = "3",
                                          Separated = "4",
                                          Widowed = "5",
                                          Other = "7"
                                          ) |>
      fct_collapse(
        Single = "Single (Never Married)",
        Married = "Married",
        Divorced = "Divorced",
        Other = c("Separated", "Widowed", "Other")
      ) |>
      # Set 'Single' as the reference group for marital status at injury
      fct_relevel("Single", "Married", "Divorced", "Other"),
    
    # Collapse and reorder the levels of 'EMPLOYMENT'
    employment_at_injury = employment_at_injury |>
      fct_recode(
        "Full Time Student" = "2",
        "Part Time Student" = "3",
        "Special Education" = "4",
        "Competitively Employed" = "5",
        "Homemaker" = "7",
        "Special Employed" = "8",
        Retired = "9",
        Unemployed = "10",
        Volunteer = "11",
        Other = "12"
      ) |>
      fct_collapse(
        "Competitively Employed" = "Competitively Employed",
        Unemployed = "Unemployed",
        Student = c("Full Time Student", "Part Time Student", "Special Education"),
        Retired = "Retired",
        Other = c("Special Employed", "Homemaker", "Volunteer", "Other")
      ) |>
      # Set 'Competitively Employed' as the reference group for employment status at injury
      fct_relevel("Competitively Employed", "Unemployed", "Student", "Retired", "Other"),
    
    # Add the SES proxy covariate based on primary health insurance coverage for rehabilitation services
    rehab_payor_primary_type = if_else(rehab_payor_primary == "2", 1, 0),
    rehab_payor_primary_type = factor(rehab_payor_primary_type, levels = c(0, 1), labels = c("Non-Medicaid", "Medicaid")),
    
    # Collapse and reorder the levels of the primary rehabilitation payor covariate
    rehab_payor_primary = rehab_payor_primary |>
      fct_recode(
        Medicare = "1",
        Medicaid = "2",
        "Workers Compensation" = "3",
        "Private Insurance" = "4",
        "Self or Private Pay" = "7",
        "State or County" = "8",
        "Auto Insurance" = "10",
        Charity = "14",
        Other = "15",
        "Payor Source Pending" = "55"
      ) |>
      fct_collapse(
        "Private Insurance" = c("Private Insurance", "Workers Compensation", "Auto Insurance"),
        "Public Insurance" = c("Medicaid", "Medicare", "State or County"),
        Other = c("Self or Private Pay", "Charity", "Payor Source Pending", "Other")
      ) |>
      # Set 'Private Insurance' as the reference group for Medicaid status
      fct_relevel("Private Insurance", "Public Insurance", "Other"),
    
    # Set 'No' as the reference group for the problematic substance use at time of injury covariate
    problematic_substance_use_at_injury = fct_recode(problematic_substance_use_at_injury,
                                                     No = "0",
                                                     Yes = "1"
                                                     ) |>
    fct_relevel("No", "Yes"),
    
    # Set 'No' as the reference group for the problematic substance use at follow-up covariate
    problematic_substance_use_at_followup = fct_recode(problematic_substance_use_at_followup,
                                                       No = "0",
                                                       Yes = "1"
                                                       ) |>
    # Set 'No' as the reference group for problematic substance use at follow-up
    fct_relevel("No", "Yes"),
    
    # Set 'No' as the reference group for the lifetime hx of mental health treatment at time of injury covariate
    mental_health_tx_lifetime_at_injury = fct_recode(mental_health_tx_lifetime_at_injury,
                                                     No = "0",
                                                     Yes = "1"
                                                     # "Not Applicable" = "88"  # '88' code not present in current dataset
                                                     ) |>
    fct_relevel("No", "Yes"),
      
    # Set 'No' as the reference group for the past-year hx of mental health treatment at time of injury covariate
    mental_health_tx_past_year_at_injury = fct_recode(mental_health_tx_past_year_at_injury,
                                                      No = "0",
                                                      Yes = "1",
                                                      "Not Applicable" = "88"  # '88' code not present in current dataset
                                                      ) |>
      fct_collapse(
        No = c("No", "Not Applicable"),
        Yes = "Yes"
        ) |>
      fct_relevel("No", "Yes"),
    
    # Set 'No' as the reference group for the lifetime hx of psychiatric hospitalization at time of injury covariate
    psych_hosp_hx_lifetime_at_injury = fct_recode(psych_hosp_hx_lifetime_at_injury,
                                                  No = "0",
                                                  Yes = "1",
                                                  "Not Applicable" = "88"
                                                  ) |>
      fct_collapse(
        No = c("No", "Not Applicable"),
        Yes = "Yes"
        ) |>
      fct_relevel("No", "Yes"),
    
    # Set 'No' as the reference group for the past-year hx of psychiatric hospitalization at time of injury covariate
    psych_hosp_hx_past_year_at_injury = fct_recode(psych_hosp_hx_past_year_at_injury,
                                                   No = "0",
                                                   Yes = "1",
                                                   "Not Applicable" = "88"
                                                   ) |>
      fct_collapse(
        No = c("No", "Not Applicable"),
        Yes = "Yes"
        ) |>
      fct_relevel("No", "Yes"),

    # Set 'No' as the reference group for the past-year hx of suicide attempt at time of injury covariate
    suicide_attempt_hx_lifetime_at_injury = fct_recode(suicide_attempt_hx_lifetime_at_injury,
                                              No = "0",
                                              Yes = "1"
                                              ) |>
      fct_relevel("No", "Yes"),
    
    # Set 'No' as the reference group for the past-year hx of suicide attempt at time of injury covariate
    suicide_attempt_hx_past_year_at_injury = fct_recode(suicide_attempt_hx_past_year_at_injury,
                                              No = "0",
                                              Yes = "1",
                                              "Not Applicable" = "88"
                                              ) |>
      fct_collapse(
        No = c("No", "Not Applicable"),
        Yes = "Yes"
        ) |>
      fct_relevel("No", "Yes"),
    
    # Set 'No' as the reference group for the past-year hx of suicide attempt at follow-up covariate
    suicide_attempt_hx_past_year_at_followup = fct_recode(suicide_attempt_hx_past_year_at_followup,
                                                          No = "0",
                                                          Yes = "1"
                                                          ) |>
      fct_relevel("No", "Yes")
  ) |>
  
  droplevels()  # Drop unused factor levels
```

```{r Carry Baseline Variables Forward to Subsequent Observations while Maintaining Factor Labels}
# List of baseline variables to carry forward to subsequent observations via LOCF
baseline_vars <- c(
  "date_of_birth",
  "date_of_injury",
  "sex",
  "age_at_injury",
  "cause_of_injury", 
  "marital_status_at_injury", 
  "education_level_at_injury",
  "employment_at_injury",
  "rehab_payor_primary",
  "rehab_payor_primary_type",
  "problematic_substance_use_at_injury",
  "mental_health_tx_lifetime_at_injury",
  "mental_health_tx_past_year_at_injury",
  "psych_hosp_hx_lifetime_at_injury",
  "psych_hosp_hx_past_year_at_injury",
  "suicide_attempt_hx_lifetime_at_injury",
  "suicide_attempt_hx_past_year_at_injury"
)

# Store original factor levels and labels before applying the LOCF fill to baseline variables
original_factor_info <- list()
for (var in baseline_vars) {
  if (is.factor(merged_data[[var]])) {
    original_factor_info[[var]] <- list(
      levels = levels(merged_data[[var]]),
      labels = get_labels(merged_data[[var]], values = "n")
    )
  }
}

# Convert factors to characters before applying the LOCF fill to baseline variables
merged_data <- merged_data |>
  mutate(across(all_of(baseline_vars), ~ if (is.factor(.)) { as.character(.) } else { . })) |>
  # Perform the LOCF fill of baseline variable data to all subsequent observations
  group_by(id) |>
  fill(!!!syms(baseline_vars), .direction = "down") |>
  ungroup()

# Convert characters back to factors with original factor levels, then set the factor labels using 'set_labels'
for (var in names(original_factor_info)) {
  if (!is.null(original_factor_info[[var]])) {
    levels_info <- original_factor_info[[var]]$levels
    labels_info <- original_factor_info[[var]]$labels

    # Convert back to factor
    merged_data[[var]] <- factor(merged_data[[var]], levels = levels_info)

    # Set labels using set_labels from sjlabelled
    merged_data[[var]] <- set_labels(merged_data[[var]], labels = setNames(levels_info, labels_info))
  }
}
```

```{r Select and Arrange the Final Data Columns in the Merged Data Frame}
# Select and reorder merged data columns
merged_data <- merged_data |>
  select(
    id,
    status_at_followup,
    data_collection_period,
    date_of_year_1_followup,
    date_of_followup,
    date_of_death,
    date_of_birth,
    date_of_injury,
    sex,
    age_at_injury,
    cause_of_injury,
    cause_of_death_1,
    cause_of_death_2,
    cause_of_death_e,
    marital_status_at_injury,
    education_level_at_injury,
    employment_at_injury,
    rehab_payor_primary,
    rehab_payor_primary_type,
    drs_total_at_followup,
    fim_total_at_followup,
    gose_total_at_followup,
    drs_total_at_year_1,
    fim_total_at_year_1,
    gose_total_at_year_1,
    func_score_at_year_1,
    func_score_at_year_1_q5,
    mental_health_tx_lifetime_at_injury,
    mental_health_tx_past_year_at_injury,
    psych_hosp_hx_lifetime_at_injury,
    psych_hosp_hx_past_year_at_injury,
    problematic_substance_use_at_injury,
    problematic_substance_use_at_followup,
    suicide_attempt_hx_lifetime_at_injury,
    suicide_attempt_hx_past_year_at_injury,
    suicide_attempt_hx_past_year_at_followup,
    phq1, phq2, phq3, phq4, phq5, phq6, phq7, phq8, phq9
    ) |>
  arrange(id, data_collection_period)
```

# Define Logging Functions

```{r Define a Function to Log the Sample Sizes After Applying Each Study Eligibility Criterion}
# Function to log sample size
log_sample_size <- function(data, criterion_number, log_dir = here::here("Logs"), original_data = NULL) {
  # Ensure the 'log_dir' directory exists
  if (!dir.exists(log_dir)) {
    dir.create(log_dir, recursive = TRUE)
  }

  # Create the log file name
  log_file <- file.path(log_dir, "sample_sizes.log")

  # Calculate the number of unique IDs and total observations
  unique_ids <- length(unique(data$id))
  total_observations <- nrow(data)
  original_unique_ids <- if (!is.null(original_data)) length(unique(original_data$id)) else NA

  # Format the message
  message <- sprintf(
    "Original Unique IDs: %s\n Unique IDs after Applying Criterion %d: %s\n Total Observations after Applying Criterion %d: %s\n\n",
    format(original_unique_ids, big.mark = ","),
    criterion_number,
    format(unique_ids, big.mark = ","),
    criterion_number,
    format(total_observations, big.mark = ",")
  )
  
  # Append the message to the log file
  cat(message, file = log_file, append = TRUE)
}
```

```{r Define a Function to Log the Number of Participants Removed after Applying Each Study Eligibility Criterion}
# Function to log removed participant IDs after applying study eligibility criteria
log_removed_ids <- function(original_data, filtered_data, criterion_number, log_dir = here::here("Logs")) {
  # Ensure the 'log_dir' directory exists
  if (!dir.exists(log_dir)) {
    dir.create(log_dir, recursive = TRUE)
  }

  # Find IDs removed by the criterion
  removed_ids <- setdiff(unique(original_data$id), unique(filtered_data$id))
  
  # Write IDs to a log file
  log_file <- file.path(log_dir, sprintf("criterion_%d_removed_ids.log", criterion_number))
  writeLines(as.character(removed_ids), log_file)
}
```

### Define a Helper Function to Dynamically Calculate Each Participant's End Date

```{r Define a Helper Function to Dynamically Calculate Each Participants End Date}
# Define a function to dynamically calculate each participant's end date
is_within_study_period <- function(date_of_year_1_followup, date_of_followup) {
  participant_end_date <- date_of_year_1_followup + years(5)
  !is.na(date_of_followup) & date_of_followup >= study_entry_period_start_date & date_of_followup <= participant_end_date
}
```

The `apply_labels_to_renamed_vars` function is used to assign stored variable labels to renamed variables in a dataset. In this particular case, it enables us to rename the variables according to tidyverse style guidelines while retaining all original meaningful descriptors The function first unlists the baseline and follow-up labels to flatten them for easier manipulation and then iterates through each mapping rule in `baseline_mappings` and `followup_mappings` to locate the corresponding old name for each new variable name and then applying the appropriate label from `baseline_labels` and `followup_labels` to the new variable names in `merged_data`.

```{r Define a Function to Apply Original Variable Labels to Renamed Variables}
# Function to apply original variable labels to renamed variables
apply_labels_to_renamed_vars <- function(merged_data, baseline_labels, followup_labels, baseline_mappings, followup_mappings) {
  # Unlist the labels
  baseline_labels_unlisted <- unlist(baseline_labels)
  followup_labels_unlisted <- unlist(followup_labels)

  # Apply TBIMS Form 1 (baseline) labels
  for (new_name in names(baseline_mappings)) {
    original_name <- baseline_mappings[[new_name]]$original_name
    if (!is.null(baseline_labels_unlisted[original_name])) {
      var_label(merged_data[[new_name]]) <- baseline_labels_unlisted[original_name]
    }
  }

  # Apply TBIMS Form 2 (follow-up) labels
  for (new_name in names(followup_mappings)) {
    original_name <- followup_mappings[[new_name]]$original_name
    if (!is.null(followup_labels_unlisted[original_name])) {
      var_label(merged_data[[new_name]]) <- followup_labels_unlisted[original_name]
    }
  }

  return(merged_data)
}
```

```{r Define a Function to Apply Study Eligibility Criterion 1 (Inclusion): First interview between October 1, 2006 and October 1, 2012 with Follow-Up for Up to 5 or 10 Years Post-Year 1 Interview}
# Function to apply Study Eligibility Criterion 1
apply_criterion_1 <- function(data, study_entry_period_start_date, study_entry_period_end_date) {
  original_data <- data  # Store the original data for logging removed IDs
  
  data <- data |>
    filter(date_of_year_1_followup >= study_entry_period_start_date & date_of_year_1_followup <= study_entry_period_end_date) |>
    arrange(id, date_of_followup, date_of_death) |>
    group_by(id) |>
    mutate(
      participant_end_date = date_of_year_1_followup + years(5),
      valid_followup = is_within_study_period(date_of_year_1_followup, date_of_followup) | 
        is_within_study_period(date_of_year_1_followup, date_of_death),
      special_case = status_at_followup %in% c("Lost", "Refused", "Incarcerated", "Withdrew", "No Funding"),
      include_observation = if_else(data_collection_period == 0, TRUE, valid_followup | (special_case & lead(as.logical(valid_followup, default = FALSE)))),
      calendar_year_of_event = if_else(!is.na(date_of_death), year(date_of_death),
                                       if_else(!is.na(date_of_followup), year(date_of_followup), NA_integer_)),
      calendar_year_of_injury = year(date_of_injury)
    ) |>
    filter(include_observation) |>
    mutate(
      event_status = if_else(!is.na(date_of_death) & date_of_death <= participant_end_date, 1, 0),
      time_to_censorship = if_else(is.na(date_of_death) & is.na(date_of_followup), 0, 
                                   if_else(!is.na(date_of_followup), as.numeric(difftime(date_of_followup, date_of_year_1_followup, units = "days")), NA_real_)),
      time_to_expiration = if_else(is.na(date_of_death) & is.na(date_of_followup), 0, 
                                   if_else(!is.na(date_of_death), as.numeric(difftime(date_of_death, date_of_year_1_followup, units = "days")), NA_real_)),
      time_to_event = if_else(!is.na(date_of_death), time_to_expiration,
                              if_else(!is.na(time_to_censorship), time_to_censorship, NA_real_))
    ) |>
    ungroup() |>
    select(id, data_collection_period, status_at_followup, event_status,
           time_to_event, time_to_censorship, time_to_expiration,
           calendar_year_of_injury, calendar_year_of_event, date_of_year_1_followup,
           date_of_followup, date_of_death, participant_end_date, everything()) |>
    select(-valid_followup, -special_case, -include_observation) |>
    arrange(id, data_collection_period)
  
  # Log the sample size after applying Criterion 1
  log_sample_size(data, 1, log_dir = here::here("Logs"), original_data)
  
  # Log the removed IDs
  log_removed_ids(original_data, data, 1, log_dir = here::here("Logs"))

  return(data)
}
```

```{r Define a Function to Apply Study Eligibility Criterion 2 (Exclusion): Remove Cases with Early Mortality or a Negative Survival Time}
# Function to apply Study Eligibility Criterion 2
apply_criterion_2 <- function(data) {
  original_data <- data  # Store the original data for logging the removed IDs

  data <- data |>
    group_by(id) |>
    mutate(last_observation = row_number() == n()) |>
    filter(time_to_event > 0 | data_collection_period == 1 & !last_observation) |>
    ungroup() |>
    select(-last_observation)

  # Log the sample size after applying Criterion 2
  log_sample_size(data, 2, log_dir = here::here("Logs"))

  # Log the removed IDs
  log_removed_ids(original_data, data, 2, log_dir = here::here("Logs"))

  return(data)
}
```

## Study Eligibility Criterion 3 (Inclusion): Determinate Date Data for Calculating Survival Times

The `apply_criterion_3` function is designed to apply the final study eligibility criterion, which requires that all participants have the necessary date data for the calculation of survival times. This function requires the specification of the data frame (`data`) as well as the parameters `tbims_form1_labels`, `tbims_form2_labels`, `baseline_name_and_na_mappings`, and `followup_name_and_na_mappings`, which contain additional information about variable labels and mappings for baseline and follow-up data. The function starts by grouping data by participant ID and filtering out those without a valid follow-up or expiration date (`last_valid_date`). These dates are essential for calculating survival times. Next, the function applies the original TBIMS Form 1 and Form 2 labels to the renamed variables, using the mappings provided in the additional parameters. As in the previous functions, the sample size log is then updated with the new sample size after applying this criterion, and the IDs of excluded participants are logged. The final output is a dataset with participants who fulfilled all three study eligibility criteria, with appropriately labeled variables.

```{r Define a Function to Apply Study Eligibility Criterion 3 (Inclusion): Availability of Determinate Date Data for Calculating Survival Time}
# Function to apply Study Eligibility Criterion 3
apply_criterion_3 <- function(data, tbims_form1_labels, tbims_form2_labels, baseline_name_and_na_mappings, followup_name_and_na_mappings) {
  original_data <- data  # Store the original data for logging removed IDs

  data <- data |>
    arrange(id, date_of_followup, date_of_death) |>
    group_by(id) |>
    mutate(
      is_last_observation = lead(id, default = last(id)) != id,
      last_valid_date = pmax(date_of_followup, date_of_death, na.rm = TRUE)
    ) |>
    filter(any(!is.na(last_valid_date))) |>
    ungroup() |>
    select(-is_last_observation, -last_valid_date)

  # Apply original variable labels to renamed variables
  data <- apply_labels_to_renamed_vars(
    data, 
    tbims_form1_labels, 
    tbims_form2_labels, 
    baseline_name_and_na_mappings, 
    followup_name_and_na_mappings
  )

  # Log the sample size after applying Criterion 3
  log_sample_size(data, 3, log_dir = here::here("Logs"))

  # Log the removed IDs
  log_removed_ids(original_data, data, 3, log_dir = here::here("Logs"))


  return(data)
}
```

## Call the Study Eligibility Criteria Functions

```{r Call the study eligibility criteria functions}
# Apply Study Eligibility Criterion 1
analytic_data <- apply_criterion_1(merged_data, study_entry_period_start_date, study_entry_period_end_date)

# Apply Study Eligibility Criterion 2
analytic_data <- apply_criterion_2(analytic_data)

# Apply Study Eligibility Criterion 3
analytic_data <- apply_criterion_3(analytic_data, tbims_form1_labels, tbims_form2_labels, baseline_name_and_na_mappings, followup_name_and_na_mappings)
```

## Calculate Depression Level at Year 1

```{r Define a Function to Calculate Depression Levels at Year 1}
# Function to calculate Depression Level based on Year 1 PHQ-9 Questionnaire Responses
calculate_depression_level <- function(data) {
  data <- data |> 
    mutate(
      # Initialize new columns with default NA values
      positive_symptoms_at_year_1 = NA_real_,
      cardinal_symptoms_at_year_1 = factor(NA, levels = c("0", "1", "2", "3")),
      depression_level_at_year_1 = factor(NA, levels = c("0", "1", "2"))
    ) |>
    rowwise() |> 
    mutate(
      # all_phq_na = all(is.na(c_across(starts_with("phq")))),
      positive_symptoms_at_year_1 = if_else(data_collection_period == 1, 
                                            # sum(c_across(starts_with("phq")) >= 1, na.rm = TRUE),
                                            sum(c_across(starts_with("phq")) >= 1),
                                            NA_real_),
      cardinal_symptoms_at_year_1 = factor(if_else(data_collection_period == 1, 
                                                   case_when(
                                                     phq1 < 1 & phq2 < 1 ~ "0",  # Denied both cardinal symptoms
                                                     phq1 >= 1 & phq2 < 1 ~ "1", # Endorsed anhedonia only
                                                     phq1 < 1 & phq2 >= 1 ~ "2", # Endorsed depressed mood only
                                                     phq1 >= 1 & phq2 >= 1 ~ "3" # Endorsed both cardinal symptoms
                                                   ),
                                                   NA_character_),
                                            levels = c("0", "1", "2", "3"), 
                                            labels = c("None", "Anhedonia", "Depressed Mood", "Both")),
      depression_level_at_year_1 = factor(if_else(data_collection_period == 1, 
                                                  case_when(
                                                    positive_symptoms_at_year_1 <= 1 | (phq1 < 1 & phq2 < 1) ~ "0",   # Assign 'No Depression' label
                                                    positive_symptoms_at_year_1 <= 4 & (phq1 >= 1 | phq2 >= 1) ~ "1", # Assign 'Minor Depression' label
                                                    positive_symptoms_at_year_1 >= 5 & (phq1 >= 1 | phq2 >= 1) ~ "2"  # Assign 'Major Depression' label
                                                  ),
                                                  NA_character_),
                                          levels = c("0", "1", "2"), 
                                          labels = c("No Depression", "Minor Depression", "Major Depression"))
    ) |> 
    ungroup()
    # select(-all_phq_na)

  return(data)
}

# Calculate the Year 1 depression levels for the analytic sample
analytic_data_depression <- calculate_depression_level(analytic_data)
```

```{r Define a Function to Extract the Year 1 Variables of Interest and Impute the Values to Previous and Subsequent Observations}
# Function to extract and impute Year 1 Data
extract_and_impute_year_1_data <- function(data) {
    # Specify the variables to extract and impute
    vars_to_extract <- c("drs_total_at_followup", 
                         "fim_total_at_followup", 
                         "gose_total_at_followup", 
                         "problematic_substance_use_at_followup", 
                         "suicide_attempt_hx_past_year_at_followup")
    year_1_vars_to_impute <- c("cardinal_symptoms_at_year_1", 
                               "positive_symptoms_at_year_1", 
                               "depression_level_at_year_1")
    
    # Extract Year 1 values and create new columns
    for (var in vars_to_extract) {
      # Replace '_followup' with '_year_1' in the variable name
      new_var_name <- sub("_followup", "_year_1", var)
      data <- data |>
        mutate(!!new_var_name := if_else(data_collection_period == 1, !!sym(var), NA))
      year_1_vars_to_impute <- c(year_1_vars_to_impute, new_var_name)
    }

    # Impute the values across all observations per participant
    imputed_data <- data |>
      group_by(id) |>
      fill(!!!syms(year_1_vars_to_impute), .direction = "downup")
    
    return(imputed_data)
}

# Extract and impute the Year 1 variables of interest for the analytic sample
analytic_data_imputed <- extract_and_impute_year_1_data(analytic_data_depression)
```

```{r Define a Function to Create a New Factor Variable to Represent Self-Reported History of Suicide Attempt}
# Function to create a new factor variable representing full history of suicide attempt
create_suicide_attempt_hx_factor <- function(lifetime, past_year_at_injury, past_year_at_year_1) {
  # Initialize the vector for the new factor variable
  new_factor <- integer(length = length(lifetime))
  
  for(i in 1:length(lifetime)) {
    if(is.na(lifetime[i]) || is.na(past_year_at_injury[i]) || is.na(past_year_at_year_1[i])) {
      new_factor[i] <- NA # Assign NA for missing data
    } else if(lifetime[i] == "No" && past_year_at_injury[i] == "No" && past_year_at_year_1[i] == "No") {
      new_factor[i] <- 0 # Denied any history
    } else if(past_year_at_year_1[i] == "Yes") {
      new_factor[i] <- 2 # Suicide attempt in the first year post-injury
    } else if(lifetime[i] == "Yes" || past_year_at_injury[i] == "Yes") {
      new_factor[i] <- 1 # Suicide attempt history prior to injury
    } else if(lifetime[i] == "Refused" || past_year_at_injury[i] == "Refused" || past_year_at_year_1[i] == "Refused") {
      new_factor[i] <- NA # Assign NA for refused to answer
    } else {
      new_factor[i] <- NA # Catch-all for any undefined cases
    }
  }
  
  # Convert to factor with descriptive labels
  new_factor <- factor(new_factor, levels = c(0, 1, 2),
                       labels = c("Denied any history of suicide attempt",
                                  "Suicide attempt history prior to injury",
                                  "Suicide attempt in the first year post-injury"))
  
  return(new_factor)
}

# Call the function and assign the result to a new column in the data frame
analytic_data_imputed$suicide_attempt_hx = create_suicide_attempt_hx_factor(
  lifetime = analytic_data_imputed$suicide_attempt_hx_lifetime_at_injury,
  past_year_at_injury = analytic_data_imputed$suicide_attempt_hx_past_year_at_injury,
  past_year_at_year_1 = analytic_data_imputed$suicide_attempt_hx_past_year_at_year_1
)

# Remove unused factor levels from the newly created variable
analytic_data_imputed$suicide_attempt_hx <- droplevels(analytic_data_imputed$suicide_attempt_hx)
```

```{r Define a Function to Create a New Factor Variable to Represent Self-Reported History of Mental Health Treatment}
# Function to create a new factor variable representing full history of mental health treatment
create_mental_health_tx_factor <- function(lifetime, past_year_at_injury) {
  # Initialize the vector for the new factor variable
  new_factor <- integer(length = length(lifetime))
  
  for(i in 1:length(lifetime)) {
    if(is.na(lifetime[i]) || is.na(past_year_at_injury[i])) {
      new_factor[i] <- NA # Assign NA for missing data
    } else if(lifetime[i] == "No" && past_year_at_injury[i] == "No") {
      new_factor[i] <- 0 # Denied any history of mental health treatment
    } else if(lifetime[i] == "Yes" && past_year_at_injury[i] == "No") {
      new_factor[i] <- 1 # Mental health treatment endorsed prior to year preceding index injury only
    } else if(lifetime[i] == "Yes" && past_year_at_injury[i] == "Yes") {
      new_factor[i] <- 2 # Mental health treatment endorsed at time of injury
    } else if(lifetime[i] == "Refused" || past_year_at_injury[i] == "Refused") {
      new_factor[i] <- 5 # Participant refused to provide full mental health history
    } else {
      new_factor[i] <- 6 # Inconsistent reports of mental health history across time points
    }
  }
  
  # Convert to factor with descriptive labels
  new_factor <- factor(new_factor, levels = c(0, 1, 2, 5, 6),
                       labels = c("Denied any history of mental health treatment",
                                  "Mental health treatment received prior to year preceding index injury only",
                                  "Mental health treatment received within year preceding index injury",
                                  "Participant refused to provide full mental health history",
                                  "Inconsistent reports of mental health history across time points"))
  
  return(new_factor)
}

# Call the function and assign the result to a new column in the data frame
analytic_data_imputed$mental_health_tx_hx = create_mental_health_tx_factor(
  lifetime = analytic_data_imputed$mental_health_tx_lifetime_at_injury,
  past_year_at_injury = analytic_data_imputed$mental_health_tx_past_year_at_injury
)

# Remove unused factor levels from the newly created variable
analytic_data_imputed$mental_health_tx_hx <- droplevels(analytic_data_imputed$mental_health_tx_hx)
```

```{r Define a Function to Create a New Factor Variable to Represent Self-Reported History of Psychiatric Hospitalization}
# Function to create a new factor variable representing full history of psychiatric hospitalization
create_psych_hosp_hx_factor <- function(lifetime, past_year_at_injury) {
  # Initialize the vector for the new factor variable
  new_factor <- integer(length = length(lifetime))
  
  for(i in 1:length(lifetime)) {
    if(is.na(lifetime[i]) || is.na(past_year_at_injury[i])) {
      new_factor[i] <- NA # Assign NA for missing data
    } else if(lifetime[i] == "No" && past_year_at_injury[i] == "No") {
      new_factor[i] <- 0 # Denied any history of psychiatric hospitalization
    } else if(lifetime[i] == "Yes" && past_year_at_injury[i] == "No") {
      new_factor[i] <- 1 # Endorsed psychiatric hospital admission prior to year preceding index injury only
    } else if(lifetime[i] == "Yes" && past_year_at_injury[i] == "Yes") {
      new_factor[i] <- 2 # Endorsed psychiatric hospital admission within year preceding index injury
    } else if(lifetime[i] == "Refused" || past_year_at_injury[i] == "Refused") {
      new_factor[i] <- 5 # Participant refused to provide full psychiatric hospitalization history
    } else {
      new_factor[i] <- 6 # Inconsistent reports of psychiatric hospitalization history across time points
    }
  }
  
  # Convert to factor with descriptive labels
  new_factor <- factor(new_factor, levels = c(0, 1, 2, 5, 6),
                       labels = c("Denied any history of psychiatric hospitalization",
                                  "Psychiatric hospital admission prior to year preceding index injury only",
                                  "Psychiatric hospital admission within year preceding index injury",
                                  "Participant refused to provide full psychiatric hospitalization history",
                                  "Inconsistent reports of psychiatric hospitalization history across time points"))
  
  return(new_factor)
}

# Call the function and assign the result to a new column in the data frame
analytic_data_imputed$psych_hosp_hx = create_psych_hosp_hx_factor(
  lifetime = analytic_data_imputed$psych_hosp_hx_lifetime_at_injury,
  past_year_at_injury = analytic_data_imputed$psych_hosp_hx_past_year_at_injury
)

# Remove unused factor levels from the newly created variable
analytic_data_imputed$psych_hosp_hx <- droplevels(analytic_data_imputed$psych_hosp_hx)
```

```{r Convert the Units of the Time-to-Event Variables from Days to Years Select and Arrange the Columns in the Imputed Analytic Sample Data Frame}
# Convert 'time_to_event', 'time_to_censorship', and 'time_to_expiration' from days to years
analytic_data_imputed <- analytic_data_imputed |>
  mutate(
    time_to_event_in_years = time_to_event / 365.25,
    time_to_censorship_in_years = time_to_censorship / 365.25,
    time_to_expiration_in_years = time_to_expiration / 365.25,
    # Calculate age at censorship by subtracting date_of_birth from date_of_followup
    age_at_censorship = interval(start = date_of_birth, end = date_of_followup) / years(1),
    # Calculate age at death by subtracting date_of_birth from date_of_death
    age_at_expiration = interval(start = date_of_birth, end = date_of_death) / years(1)
  ) |>
  # Select and reorder data columns
  select(
    id,
    status_at_followup,
    event_status,
    data_collection_period,
    time_to_event,
    time_to_censorship,
    time_to_expiration,
    time_to_event_in_years,
    time_to_censorship_in_years,
    time_to_expiration_in_years,
    calendar_year_of_injury,
    calendar_year_of_event,
    date_of_year_1_followup,
    date_of_followup,
    date_of_death,
    date_of_birth,
    date_of_injury,
    cause_of_death_1,
    cause_of_death_2,
    cause_of_death_e,
    sex, 
    age_at_injury,
    age_at_censorship, 
    age_at_expiration,
    education_level_at_injury,
    employment_at_injury,
    marital_status_at_injury,
    cause_of_injury,
    rehab_payor_primary,
    rehab_payor_primary_type,
    drs_total_at_followup,
    fim_total_at_followup,
    gose_total_at_followup,
    drs_total_at_year_1,
    fim_total_at_year_1,
    gose_total_at_year_1,
    func_score_at_year_1,
    func_score_at_year_1_q5,
    mental_health_tx_lifetime_at_injury,
    mental_health_tx_past_year_at_injury,
    mental_health_tx_hx,
    psych_hosp_hx_lifetime_at_injury,
    psych_hosp_hx_past_year_at_injury,
    psych_hosp_hx,
    problematic_substance_use_at_injury,
    problematic_substance_use_at_year_1,
    problematic_substance_use_at_followup,
    suicide_attempt_hx_lifetime_at_injury,
    suicide_attempt_hx_past_year_at_injury,
    suicide_attempt_hx_past_year_at_year_1,
    suicide_attempt_hx_past_year_at_followup,
    suicide_attempt_hx,
    phq1, phq2, phq3, phq4, phq5, phq6, phq7, phq8, phq9,
    positive_symptoms_at_year_1,
    cardinal_symptoms_at_year_1,
    depression_level_at_year_1
    ) |>
  arrange(id, data_collection_period)

# Save the 'analytic_data_imputed' data frame in a single .rds file
saveRDS(analytic_data_imputed, here(data_processed_dir, "analytic_data_imputed.rds"))

# Save the 'analytic_data_imputed' data frame as a CSV file in the 'data/processed/5_year_followup' subdirectory
write.csv(analytic_data_imputed, file.path(data_processed_dir, "analytic_data_imputed.csv"), row.names = FALSE)
```

```{r Retain Only the Last Valid Observation Per Participant}
# Retain only the last observation for each unique 'id' based on the maximum 'time_to_event' value
analytic_data_final <- analytic_data_imputed |>
  arrange(id, time_to_event) |>
  group_by(id) |>
  slice(n()) |>
  ungroup()

# Replace empty strings with NA in all columns
analytic_data_final <- apply(analytic_data_final, 2, function(x) ifelse(x == "", NA, x))

# Convert 'analytic_data_final' to a data frame
analytic_data_final <- as.data.frame(analytic_data_final)

# Function to match the class of one column to another
match_class <- function(target_col, reference_col) {
  target_class <- class(reference_col)
  
  if ("factor" %in% target_class) {
    return(as.factor(target_col))
  } else if ("numeric" %in% target_class) {
    return(as.numeric(target_col))
  } else if ("integer" %in% target_class) {
    return(as.integer(target_col))
  } else if ("character" %in% target_class) {
    return(as.character(target_col))
  } else if ("logical" %in% target_class) {
    return(as.logical(target_col))
  } else if ("Date" %in% target_class) {
    return(as.Date(target_col))
  } else {
    stop(paste("Unsupported class:", target_class))
  }
}

# Apply the function to each column
analytic_data_final <- analytic_data_final |>
  mutate(across(everything(), ~ match_class(.x, analytic_data_imputed[[cur_column()]])))

# Adjust the levels of the factor variables
analytic_data_final <- analytic_data_final |>
  mutate(
    depression_level_at_year_1 = factor(depression_level_at_year_1,
                                        levels = c("No Depression",
                                                   "Minor Depression",
                                                   "Major Depression")),
    event_status = factor(event_status), 
    event_status = fct_recode(event_status,
                             Censored = "0",
                             Expired = "1"
                             ) |>
      fct_relevel("Censored", "Expired"),
    sex = factor(sex, 
                 levels = c("Male", "Female")),
    employment_at_injury = factor(employment_at_injury, 
                                  levels = c("Competitively Employed", 
                                             "Unemployed", 
                                             "Student", 
                                             "Retired", 
                                             "Other")),
    marital_status_at_injury = factor(marital_status_at_injury,
                                      levels = c("Single",
                                                 "Married",
                                                 "Divorced",
                                                 "Other")),
    rehab_payor_primary = factor(rehab_payor_primary,
                                 levels = c("Private Insurance", "Public Insurance", "Other")),
    rehab_payor_primary_type = factor(rehab_payor_primary_type, 
                                      levels = c("Non-Medicaid", "Medicaid")),
    cause_of_injury = factor(cause_of_injury,
                             levels = c("Vehicular",
                                        "Falls",
                                        "Violence",
                                        "Other")),
    mental_health_tx_lifetime_at_injury = factor(mental_health_tx_lifetime_at_injury,
                                                 levels = c("No", "Yes")),
    mental_health_tx_past_year_at_injury = factor(mental_health_tx_past_year_at_injury,
                                                  levels = c("No", "Yes")),
    mental_health_tx_hx = factor(mental_health_tx_hx,
                                 levels = c("Denied any history of mental health treatment",
                                            "Mental health treatment received prior to year preceding index injury only",
                                            "Mental health treatment received within year preceding index injury")),
    psych_hosp_hx_lifetime_at_injury = factor(psych_hosp_hx_lifetime_at_injury,
                                              levels = c("No", "Yes")),
    psych_hosp_hx_past_year_at_injury = factor(psych_hosp_hx_past_year_at_injury,
                                               levels = c("No", "Yes")),
    psych_hosp_hx = factor(psych_hosp_hx,
                           levels = c("Denied any history of psychiatric hospitalization",
                                      "Psychiatric hospital admission prior to year preceding index injury only",
                                      "Psychiatric hospital admission within year preceding index injury")),
    problematic_substance_use_at_injury = factor(problematic_substance_use_at_injury,
                                                 levels = c("No",
                                                            "Yes")),
    problematic_substance_use_at_year_1 = factor(problematic_substance_use_at_year_1,
                                                 levels = c("No",
                                                            "Yes")),
    suicide_attempt_hx_lifetime_at_injury = factor(suicide_attempt_hx_lifetime_at_injury,
                                                   levels = c("No", "Yes")),
    suicide_attempt_hx_past_year_at_injury = factor(suicide_attempt_hx_past_year_at_injury,
                                                    levels = c("No", "Yes")),
    suicide_attempt_hx_past_year_at_year_1 = factor(suicide_attempt_hx_past_year_at_year_1,
                                                    levels = c("No", "Yes")),
    suicide_attempt_hx = factor(suicide_attempt_hx, 
                                levels = c("Denied any history of suicide attempt", 
                                           "Suicide attempt history prior to injury", 
                                           "Suicide attempt in the first year post-injury"))
  )

analytic_data_final <- apply_labels_to_renamed_vars(
  merged_data = analytic_data_final,
  baseline_labels = tbims_form1_labels,
  followup_labels = tbims_form2_labels,
  baseline_mappings = baseline_name_and_na_mappings,
  followup_mappings = followup_name_and_na_mappings
)

# Save the 'analytic_data_final' data frame in a single .rds file
saveRDS(analytic_data_final, here(data_processed_dir, "analytic_data_final.rds"))

# Save the 'analytic_data_final' data frame as a CSV file in the 'data/processed' subdirectory
write.csv(analytic_data_final, file.path(data_processed_dir, "analytic_data_final.csv"), row.names = FALSE)
```

```{r Create Long Format Data Frame}
# Extract the list of unique `id`s from the `analytic_data_final` data frame
id_list <- analytic_data_final$id

# Use this list of `id`s to filter `merged_data` to include all observations per `id`
analytic_data_final_long <- analytic_data_imputed |>
  filter(id %in% id_list)

# Save the 'analytic_data_final' data frame in a single .rds file
saveRDS(analytic_data_final_long, here(data_processed_dir, "analytic_data_final_long.rds"))

# Save the 'analytic_data_final' data frame as a CSV file in the 'data/processed' subdirectory
write.csv(analytic_data_final_long, file.path(data_processed_dir, "analytic_data_final_long.csv"), row.names = FALSE)
```
